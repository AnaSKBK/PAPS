# Лабораторная работа №3
Тема: Использование принципов проектирования на уровне методов и классов.
Цель работы: Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY и SOLID.

# Диаграмма компонентов
![Диаграмма компонентов](https://github.com/AnaSKBK/PAPS/assets/128895913/74ca0b3f-baf8-4ab5-a771-5b81e1134efd)
# Модель БД
![БД](https://github.com/AnaSKBK/PAPS/blob/LabWork3/PAPS_3_DB.jpg)
# Применение основных принципов разработки
Данный фрагмент кода соответствует основным принципам разработки. 
 - KISS. Данный код прост и понятен, в нем нет сложных конструкций.
 - YAGNI. В данном коде есть только необходимый на данный момент функционал.
 - DRY. В данном коде используются функции, это помогает избежать дублирования кода. 
 - SOLID:
   - S - Single Responsibility Principle (Принцип единственной ответственности). Компонент должен быть ответственен за что-то одно, например только хранение данных или манипуляция с ними.
     ```
     class Presentation {
     constructor(name: string){ }
     getPresentationName() { }
     }
     class PresentationDB {
     getPresentation (a: Presentation) { }
     savePresentation(a: Presentation) { }
     }
     ```
   - O - Open-Closed Principle (Принцип открытости-закрытости). Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
     ```
     class Presentation {
        makeStyle();
        //...
     }
     class StudyPresentation extends Presentation {
        makeStyle() {
         return 'school';
     }
     }

     function PresentationStyle (a: Array<Presentation>) {
          for(int i = 0; i <= a.length; i++) {
              a[i].makeStyle();
          }
      }
     PresentationStyle(presentations);
     ```
   - L - Liskov Substitution Principle (Принцип подстановки Барбары Лисков). Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
   ```
        class Presentation {
        makeStyle();
        //...
     }
     class StudyPresentation extends Presentation {
        makeStyle() {
         return 'school';
     }
     }

     function PresentationStyle (a: Array<Presentation>) {
          for(int i = 0; i <= a.length; i++) {
              a[i].makeStyle();
          }
      }
     PresentationStyle(presentations);
   ```
   - I - Interface Segregation Principle (Принцип разделения интерфейса). Интерфейсы должны быть узкоспециализированными.
   ```
   interface Presentation {
    start();
   }
   interface StudyPresentation {
    startStudyPresentation();
   }
   interface FanPresentation {
    startFanPresentation();
   }
   ```
   - D - Dependency Inversion Principle (Принцип инверсии зависимостей). Модули верхних уровней не должны зависеть от модулей нижних уровней.

# Дополнительные принципы разработки
- BDUF. Big design up front («Масштабное проектирование прежде всего»). Принцип заключается в том, что перед разработкой необходимо хорошо продумать, как это будет реализовано. Этот принцип стоит использовать, ведь такой подход поможет избежать проблем в будущем. Хоть решение проблем часто быстрее, чем составление плана, но каждая ошибка - это репутационные издержки компании.
- SoC. Separation оf concerns (принцип разделения ответственности). Принцип разработки, который подразумевает разделение кода на отдельные логические части, каждая из которых отвечает за конкретный аспект функциональности приложения. Этот принцип стоит использовать, ведь с его помощью сложность приложения (связь всего со всем) не будет нарастать. 
- MVP. Minimum viable product (минимально жизнеспособный продукт). Принцип заключается в создании "тестовой версии" продукта для проверки его жизнеспособности на рынке. Данный принцип хорош для стартапов. Но в моем случае (четкое ТЗ от заказчика) MVP не будет применяться, т.к. заказчик должен получить готовое приложение, отвечающее всем требованиям.
- PoC. Proof of concept (доказательство концепции). PoC, также как и MVP, хорош для стартапов либо для иновационных идей. Используется чтобы проверить, насколько работоспособна идея. Но в моем случае (четкое ТЗ от заказчика) PoC не будет применяться, т.к. заказчик должен получить готовое приложение, а жизнеспособность его концепции ложится на плечи заказчика.
